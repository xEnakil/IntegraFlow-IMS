package httpapi

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"
	"strconv"
	"strings"

	httpSwagger "github.com/swaggo/http-swagger"

	"github.com/xenakil/integraflow-ims/internal/domain"
	"github.com/xenakil/integraflow-ims/internal/repository"
	"github.com/xenakil/integraflow-ims/internal/service"

	// Swagger docs (generated by swag init)
	_ "github.com/xenakil/integraflow-ims/docs"
)

type Server struct {
	riskSvc      *service.RiskService
	incidentSvc  *service.IncidentService
	auditSvc     *service.AuditService
	actionSvc    *service.ActionService
	dashboardSvc *service.DashboardService
	mux          *http.ServeMux
}

func NewServer(
	riskSvc *service.RiskService,
	incidentSvc *service.IncidentService,
	auditSvc *service.AuditService,
	actionSvc *service.ActionService,
	dashboardSvc *service.DashboardService,
) *Server {
	s := &Server{
		riskSvc:      riskSvc,
		incidentSvc:  incidentSvc,
		auditSvc:     auditSvc,
		actionSvc:    actionSvc,
		dashboardSvc: dashboardSvc,
		mux:          http.NewServeMux(),
	}
	s.routes()
	return s
}

func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.mux.ServeHTTP(w, r)
}

func (s *Server) routes() {
	s.mux.HandleFunc("/api/risks", s.handleRisks)
	s.mux.HandleFunc("/api/risks/", s.handleRiskByID)

	s.mux.HandleFunc("/api/incidents", s.handleIncidents)
	s.mux.HandleFunc("/api/incidents/", s.handleIncidentByID)

	s.mux.HandleFunc("/api/audits", s.handleAudits)
	s.mux.HandleFunc("/api/audits/", s.handleAuditByID)

	s.mux.HandleFunc("/api/actions", s.handleActions)
	s.mux.HandleFunc("/api/actions/", s.handleActionByID)

	s.mux.HandleFunc("/api/dashboard", s.handleDashboard)

	// Swagger UI â†’ http://localhost:8080/swagger/index.html
	s.mux.Handle("/swagger/", httpSwagger.WrapHandler)

	// Simple health check
	s.mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("OK"))
	})
}

// --------- Risk handlers ---------

func (s *Server) handleRisks(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		s.listRisks(w, r)
	case http.MethodPost:
		s.createRisk(w, r)
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handleRiskByID(w http.ResponseWriter, r *http.Request) {
	id, err := parseID(r.URL.Path, "/api/risks/")
	if err != nil {
		http.Error(w, "invalid id", http.StatusBadRequest)
		return
	}

	switch r.Method {
	case http.MethodPut:
		s.updateRiskStatus(w, r, id)
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

// createRisk godoc
// @Summary      Create a new risk
// @Description  Creates a new IMS risk and calculates its risk score and level.
// @Tags         risks
// @Accept       json
// @Produce      json
// @Param        request  body      CreateRiskRequest  true  "Risk payload"
// @Success      201      {object}  domain.Risk
// @Failure      400      {string}  string
// @Failure      500      {string}  string
// @Router       /api/risks [post]
func (s *Server) createRisk(w http.ResponseWriter, r *http.Request) {
	var req CreateRiskRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, err)
		return
	}

	in := service.CreateRiskInput{
		Title:       req.Title,
		Process:     req.Process,
		Domain:      req.Domain,
		Description: req.Description,
		Likelihood:  req.Likelihood,
		Impact:      req.Impact,
		Owner:       req.Owner,
	}

	risk, err := s.riskSvc.CreateRisk(in)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusCreated, risk)
}

// listRisks godoc
// @Summary      List risks
// @Description  Returns all risks, optionally filtered by IMS domain and status.
// @Tags         risks
// @Produce      json
// @Param        domain  query    string  false  "Domain filter (quality|environment|ohs|isms)"
// @Param        status  query    string  false  "Status filter (Open|Accepted|Mitigated)"
// @Success      200     {array}  domain.Risk
// @Failure      400     {string} string
// @Failure      500     {string} string
// @Router       /api/risks [get]
func (s *Server) listRisks(w http.ResponseWriter, r *http.Request) {
	qs := r.URL.Query()
	domainStr := qs.Get("domain")
	status := qs.Get("status")

	filter := service.RiskListFilter{}
	if domainStr != "" {
		dom, err := domain.ParseDomain(domainStr)
		if err != nil {
			s.respondError(w, err)
			return
		}
		filter.Domain = &dom
	}
	if status != "" {
		filter.Status = &status
	}

	risks, err := s.riskSvc.ListRisks(filter)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, risks)
}

// updateRiskStatus godoc
// @Summary      Update risk status
// @Description  Updates the status of an existing risk.
// @Tags         risks
// @Accept       json
// @Produce      json
// @Param        id       path      int                     true  "Risk ID"
// @Param        request  body      UpdateRiskStatusRequest true  "New status"
// @Success      200      {object}  domain.Risk
// @Failure      400      {string}  string
// @Failure      404      {string}  string
// @Failure      500      {string}  string
// @Router       /api/risks/{id} [put]
func (s *Server) updateRiskStatus(w http.ResponseWriter, r *http.Request, id int) {
	var req UpdateRiskStatusRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, err)
		return
	}

	risk, err := s.riskSvc.UpdateStatus(id, req.Status)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, risk)
}

// --------- Incident handlers ---------

func (s *Server) handleIncidents(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		s.listIncidents(w, r)
	case http.MethodPost:
		s.createIncident(w, r)
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handleIncidentByID(w http.ResponseWriter, r *http.Request) {
	id, err := parseID(r.URL.Path, "/api/incidents/")
	if err != nil {
		http.Error(w, "invalid id", http.StatusBadRequest)
		return
	}

	switch r.Method {
	case http.MethodGet:
		s.getIncident(w, r, id)
	case http.MethodPut:
		s.updateIncident(w, r, id)
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

// createIncident godoc
// @Summary      Create a new incident
// @Description  Records an incident/nonconformity in the IMS.
// @Tags         incidents
// @Accept       json
// @Produce      json
// @Param        request  body      CreateIncidentRequest  true  "Incident payload"
// @Success      201      {object}  domain.Incident
// @Failure      400      {string}  string
// @Failure      500      {string}  string
// @Router       /api/incidents [post]
func (s *Server) createIncident(w http.ResponseWriter, r *http.Request) {
	var req CreateIncidentRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, err)
		return
	}

	in := service.CreateIncidentInput{
		Title:         req.Title,
		Description:   req.Description,
		Domain:        req.Domain,
		RelatedRiskID: req.RelatedRiskID,
		Severity:      req.Severity,
		Likelihood:    req.Likelihood,
	}

	inc, err := s.incidentSvc.CreateIncident(in)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusCreated, inc)
}

// listIncidents godoc
// @Summary      List incidents
// @Description  Returns incidents, optionally filtered by domain and status.
// @Tags         incidents
// @Produce      json
// @Param        domain  query    string  false  "Domain filter"
// @Param        status  query    string  false  "Status filter (Open|Investigation|Closed)"
// @Success      200     {array}  domain.Incident
// @Failure      400     {string} string
// @Failure      500     {string} string
// @Router       /api/incidents [get]
func (s *Server) listIncidents(w http.ResponseWriter, r *http.Request) {
	qs := r.URL.Query()
	domainStr := qs.Get("domain")
	status := qs.Get("status")

	filter := service.IncidentListFilter{}
	if domainStr != "" {
		dom, err := domain.ParseDomain(domainStr)
		if err != nil {
			s.respondError(w, err)
			return
		}
		filter.Domain = &dom
	}
	if status != "" {
		filter.Status = &status
	}

	incs, err := s.incidentSvc.ListIncidents(filter)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, incs)
}

// getIncident godoc
// @Summary      Get incident
// @Description  Returns a single incident by ID.
// @Tags         incidents
// @Produce      json
// @Param        id   path      int             true  "Incident ID"
// @Success      200  {object}  domain.Incident
// @Failure      404  {string}  string
// @Failure      500  {string}  string
// @Router       /api/incidents/{id} [get]
func (s *Server) getIncident(w http.ResponseWriter, r *http.Request, id int) {
	inc, err := s.incidentSvc.GetIncident(id)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, inc)
}

// updateIncident godoc
// @Summary      Update incident
// @Description  Updates root cause and/or status of an incident.
// @Tags         incidents
// @Accept       json
// @Produce      json
// @Param        id       path      int                   true  "Incident ID"
// @Param        request  body      UpdateIncidentRequest true  "Update payload"
// @Success      200      {object}  domain.Incident
// @Failure      400      {string}  string
// @Failure      404      {string}  string
// @Failure      500      {string}  string
// @Router       /api/incidents/{id} [put]
func (s *Server) updateIncident(w http.ResponseWriter, r *http.Request, id int) {
	var req UpdateIncidentRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, err)
		return
	}

	in := service.UpdateIncidentInput{
		RootCause: req.RootCause,
		Status:    req.Status,
	}

	inc, err := s.incidentSvc.UpdateIncident(id, in)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, inc)
}

// --------- Audit handlers ---------

func (s *Server) handleAudits(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		s.listAudits(w, r)
	case http.MethodPost:
		s.createAudit(w, r)
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handleAuditByID(w http.ResponseWriter, r *http.Request) {
	id, err := parseID(r.URL.Path, "/api/audits/")
	if err != nil {
		http.Error(w, "invalid id", http.StatusBadRequest)
		return
	}

	switch r.Method {
	case http.MethodPut:
		s.updateAudit(w, r, id)
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

// createAudit godoc
// @Summary      Create internal audit
// @Description  Creates a new IMS internal audit record.
// @Tags         audits
// @Accept       json
// @Produce      json
// @Param        request  body      CreateAuditRequest  true  "Audit payload"
// @Success      201      {object}  domain.Audit
// @Failure      400      {string}  string
// @Failure      500      {string}  string
// @Router       /api/audits [post]
func (s *Server) createAudit(w http.ResponseWriter, r *http.Request) {
	var req CreateAuditRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, err)
		return
	}

	in := service.CreateAuditInput{
		Title:       req.Title,
		Scope:       req.Scope,
		Domain:      req.Domain,
		PlannedDate: req.PlannedDate,
		Auditor:     req.Auditor,
	}

	audit, err := s.auditSvc.CreateAudit(in)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusCreated, audit)
}

// listAudits godoc
// @Summary      List audits
// @Description  Returns internal audits, optionally filtered by status.
// @Tags         audits
// @Produce      json
// @Param        status  query    string  false  "Status filter (Planned|In Progress|Completed)"
// @Success      200     {array}  domain.Audit
// @Failure      500     {string} string
// @Router       /api/audits [get]
func (s *Server) listAudits(w http.ResponseWriter, r *http.Request) {
	qs := r.URL.Query()
	status := qs.Get("status")

	var statusPtr *string
	if status != "" {
		statusPtr = &status
	}

	audits, err := s.auditSvc.ListAudits(statusPtr)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, audits)
}

// updateAudit godoc
// @Summary      Update audit
// @Description  Updates audit status and/or findings.
// @Tags         audits
// @Accept       json
// @Produce      json
// @Param        id       path      int                true  "Audit ID"
// @Param        request  body      UpdateAuditRequest true  "Update payload"
// @Success      200      {object}  domain.Audit
// @Failure      400      {string}  string
// @Failure      404      {string}  string
// @Failure      500      {string}  string
// @Router       /api/audits/{id} [put]
func (s *Server) updateAudit(w http.ResponseWriter, r *http.Request, id int) {
	var req UpdateAuditRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, err)
		return
	}

	in := service.UpdateAuditInput{
		Status:   req.Status,
		Findings: req.Findings,
	}

	audit, err := s.auditSvc.UpdateAudit(id, in)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, audit)
}

// --------- Action handlers ---------

func (s *Server) handleActions(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		s.listActions(w, r)
	case http.MethodPost:
		s.createAction(w, r)
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

func (s *Server) handleActionByID(w http.ResponseWriter, r *http.Request) {
	id, err := parseID(r.URL.Path, "/api/actions/")
	if err != nil {
		http.Error(w, "invalid id", http.StatusBadRequest)
		return
	}

	switch r.Method {
	case http.MethodPut:
		s.updateAction(w, r, id)
	default:
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
	}
}

// createAction godoc
// @Summary      Create CAPA action
// @Description  Creates a corrective/preventive action linked to a risk, incident or audit.
// @Tags         actions
// @Accept       json
// @Produce      json
// @Param        request  body      CreateActionRequest  true  "Action payload"
// @Success      201      {object}  domain.Action
// @Failure      400      {string}  string
// @Failure      500      {string}  string
// @Router       /api/actions [post]
func (s *Server) createAction(w http.ResponseWriter, r *http.Request) {
	var req CreateActionRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, err)
		return
	}

	in := service.CreateActionInput{
		Title:       req.Title,
		Description: req.Description,
		SourceType:  req.SourceType,
		SourceID:    req.SourceID,
		Owner:       req.Owner,
		DueDate:     req.DueDate,
	}

	act, err := s.actionSvc.CreateAction(in)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusCreated, act)
}

// listActions godoc
// @Summary      List actions
// @Description  Returns actions, optionally filtered by status or source type.
// @Tags         actions
// @Produce      json
// @Param        status      query    string  false  "Status filter (Open|In Progress|Done|Overdue)"
// @Param        sourceType  query    string  false  "Source type filter (Risk|Incident|Audit)"
// @Success      200         {array}  domain.Action
// @Failure      500         {string} string
// @Router       /api/actions [get]
func (s *Server) listActions(w http.ResponseWriter, r *http.Request) {
	qs := r.URL.Query()
	status := qs.Get("status")
	srcType := qs.Get("sourceType")

	filter := service.ActionListFilter{}
	if status != "" {
		filter.Status = &status
	}
	if srcType != "" {
		filter.SourceType = &srcType
	}

	acts, err := s.actionSvc.ListActions(filter)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, acts)
}

// updateAction godoc
// @Summary      Update action
// @Description  Updates the status and/or due date of an action.
// @Tags         actions
// @Accept       json
// @Produce      json
// @Param        id       path      int                 true  "Action ID"
// @Param        request  body      UpdateActionRequest true  "Update payload"
// @Success      200      {object}  domain.Action
// @Failure      400      {string}  string
// @Failure      404      {string}  string
// @Failure      500      {string}  string
// @Router       /api/actions/{id} [put]
func (s *Server) updateAction(w http.ResponseWriter, r *http.Request, id int) {
	var req UpdateActionRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.respondError(w, err)
		return
	}

	in := service.UpdateActionInput{
		Status:  req.Status,
		DueDate: req.DueDate,
	}

	act, err := s.actionSvc.UpdateAction(id, in)
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, act)
}

// --------- Dashboard handler ---------

// handleDashboard godoc
// @Summary      Get IMS dashboard
// @Description  Returns aggregated IMS KPIs (risks, incidents, actions).
// @Tags         dashboard
// @Produce      json
// @Success      200  {object}  domain.Dashboard
// @Failure      500  {string}  string
// @Router       /api/dashboard [get]
func (s *Server) handleDashboard(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		return
	}

	dash, err := s.dashboardSvc.GetDashboard()
	if err != nil {
		s.respondError(w, err)
		return
	}
	s.respondJSON(w, http.StatusOK, dash)
}

// --------- helpers ---------

func (s *Server) respondJSON(w http.ResponseWriter, status int, data any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	if err := json.NewEncoder(w).Encode(data); err != nil {
		log.Println("error writing JSON:", err)
	}
}

func (s *Server) respondError(w http.ResponseWriter, err error) {
	log.Println("error:", err)
	switch {
	case errors.Is(err, repository.ErrNotFound):
		http.Error(w, err.Error(), http.StatusNotFound)
	case errors.Is(err, service.ErrValidation),
		errors.Is(err, domain.ErrInvalidDomain):
		http.Error(w, err.Error(), http.StatusBadRequest)
	default:
		http.Error(w, "internal server error", http.StatusInternalServerError)
	}
}

func parseID(path, prefix string) (int, error) {
	trimmed := strings.TrimPrefix(path, prefix)
	trimmed = strings.Trim(trimmed, "/")
	return strconv.Atoi(trimmed)
}
